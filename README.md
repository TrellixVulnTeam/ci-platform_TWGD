CI Platform
===========


* A Jenkins master imutable docker instance
* Fully configurable from a *config.yml*

## Vision

* One Jenkins Master per Team or Project.
* One common pool of Jenkins Slaves for all Jenkins Masters (looking at you Mesos)
* Teams are free to fork the code, patches are welcome to improve the code base.
* CI tested just like any other piece of software
* Configuration is all stored in one or multiple config.yml files
* TODO: Add support for other configuration orchestrators (consul, confd, git2consul)
* TODO: Split the config.yaml into multiple files


## Requirements

* python2.7
* virtualenv
* make
* tempurl - see https://github.com/corner-shop/tempURL


## Setup

Install docker, python2.7, virtualenv


## Usage (with docker)


    cp config.yml.sample config.yml

Edit the configuration file, then:

    make build 
    make config-volume # hit control-C when finished
    make deploy


*build* generates the docker images
config-volume produces a tar.gz config file based on the config.yaml
*deploy* deploys the docker instance.


At boot, the init scripts will grab the /config/config.tar.gz and extract them
over any existing jenkins configuration. This will recycle all the jenkins
plugins, so that only plugins contained in the /config/config.tar.gz file are
available for this docker instance.

Note that any changes done through the Jenkins UI and not reflected in the
config.yaml will be lost as soon the docker instance is reloaded, OR jenkins is
restarted within the running docker instance.

Any files regarding jenkins configuration that are modified manually and are
not currently templated by *render.py* will be kept as it is, as they are
stored in the /var/lib/jenkins data volume.

Access the Jenkins Web interface on port 8888 of your laptop

## Usage (on marathon)

Upload your config to the tempurl service, example:
curl -X POST -F file=@config.yml 'http://tempurl-endpoint.service.tinc-core-vpn/api?tempurl=jenkins_config_yml_local&ttl=999' 

Then use the marathon files:

ci-platform.jenkins.marathon.app.json

ci-platform.config-volume.marathon.app.json




## Configuration

Configuration is stored in the config.yaml file

    jenkins:
        - server options
        - users and permissions
        - slave monitoring settings
        - slave setup configs
        - slave image configuration (EC2/Rackspace)
        - slave labels configuration (EC2/Rackspace/Mesos)
        - Plugins
        - Jenkins Views
        - Seed Job configuration


## Password management

To generate Jenkins users password Hashes use the following syntax

    make password salt='your funky salt' password='password forever'

## Workflow

Some guidelines for how to consume this docker instance.

1) Create a repository to store your *config.yaml*, and symlink the config.yaml to that repository.
   This repository should be restricted as getting access to the config yaml will allow access to your jenkins instance.

2) test any changes to the jenkins docker instance (new plugins, etc) using docker locally.

   The workflow is to :

     a) apply your changes to config.yaml or the provision scripts

     b) make build (if needed)

     c) make config-volume

     d) make deploy



 3) Some important facts regarding secrets.
    This page will give you some detailed info on how jenkins handles secret storage.

    http://thi√©baud.fr/jenkins_credentials.html

    To cut to the point, jenkins will store secrets encrypted on different files and not always using the same encryption mechanism.

    As an example, the user/name combo for jenkins users is a sha256 hash.

    That can be generated using ```make password```.

    However the credentials used for most jobs and plugins, tend to rely on the jenkins credentials plugin.
    Those secrets are stored in an encrypted format on the credentials.xml file.

    They are encrypted 'on save', as they are encrypted using a set of different files from the running jenkins instance.

    The way they are encrypted is well documented on that URL above.

    What we care, is that we want to make sure the secrets we store in our config.yaml file are always valid, even when we scrap the docker instance and create a new one from scratch.

    In order to achieve this, we store within our config.yaml file a copy of the secret.key and the secrets directory.

    That block is stored in the *jenkins.credentials.secrets_tar_bz* key, which was generated by:

    ```
    docker exec -it ci-platform bash
    tar cvjf /tmp/secrets.bz2 secret.key secrets/
    cat /tmp/secrets.bz2 | uuencode
    ```

    The credentials stored within that *jenkins.credentials* dict such as *StringsCredentials*, *BasicSSHUserPrivateKeys*, are encrypted as per the contents of that *jenkins.credentials.secrets_tar_bz*.

    The easiest way to update that dictionary is to create new secrets in the UI and see the new encrypted string generated in the credentials.xml file.
    ```
    docker exec -it ci-platform cat /var/lib/jenkins/credentials.xml
    ```

  4) ssh keys for the jenkins master is stored in *jenkins.jenkins_master_private_key* and *jenkins_master_public_key*

  5) the ssh keys for the jenkins slaves are stored in *cloud_pem_keys.jenkins_slave_private_key*

     This will be refactored at some point.

     Make sure the jenkins slaves contain the jenkins_master_public_key on their ~/.ssh/authorized_keys, keeping in mind that jenkins may login to different slaves using different accounts.

 6) Jenkins will send CI metrics to a stastd endpoint.

    Those settings are stored in *jenkins.statsd*

 7)  Jenkins will build jobs automatically by looking for a *jenkins-job-dsl.groovy* file across all Stash repositories.

     We restrict the search to particular Stash projects/repositories and branches through the *jenkins.seed_job* dictionary.

 8) Read through the config.yaml file and the code and submit questions/PRs for improving the documentation or the tool overall.


## Tests

There are basic tests in place, these simply check for exceptions in the log files.
They should be enough to provide some validation that the required dependencies between jenkins plugins have been satisfied.

These can be executed by:

    make tests
